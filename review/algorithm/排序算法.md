# 排序算法

常见的排序算法总结：快排，归并排序

平均时间复杂度`O(n*log(n))`,有稳定和不稳定

收集一些比较好的写法

## 快排和归并

这两个方法很像，快排类似于树的先根遍历，归并类似于树的后序遍历

### 快排

快排主要思想就是，先从待排序数组中选出一个元素，以该元素为界，将大于和小于该元素的其他元素，分置两边，这样，该元素就放到了其最终的位置，然后再对左右两堆元素分别进行快排，这有点类似于先序遍历

```java
public void quick(int[] nums, int start, int end) {
    if (start >= end) return;
    int left = start, right = end, pivot = nums[start];
    // 双指针，左右开弓
    while (left < right) {
        // 右边小的放左边
        while (left < right && nums[right] >= pivot) right--;
        if (left < right) nums[left++] = nums[right];
        // 左边小的放右边
        while (left < right && nums[left] <= pivot) left++;
        if (left < right) nums[right--] = nums[left];
    }
    nums[left] = pivot;
    quick(nums, 0, left - 1);
    quick(nums, left + 1, end);
}
```

关键：左右开弓双指针的方法，很是巧妙，比自己想到的通过逐个交换的方法要好

### 归并

归并排序的主要思想是，先将待排序数组一分为二，然后对左右两个子数组使用归并排序，然后再对两个有序的子数组进行有序合并，（先左右，再根，很像后序遍历）

```java
public void merge(int[] nums, int start, int end) {
    if (start >= end) return;
    int mid = (start + end) >> 1;
    // 分
    merge(nums, start, mid);
    merge(nums, mid + 1, end);
    // 合
    int left = start, right = mid + 1, pt = 0;
    int[] tmp = new int[end - start + 1];
    // 有序数组合并
    while (left <= mid && right <= end) {
        tmp[pt++] = nums[left] < nums[right] ? nums[left++] : nums[right++];
    }
    while (left <= mid) tmp[pt++] = nums[left++];
    while (right <= end) tmp[pt++] = nums[right++];
    System.arraycopy(tmp, 0, nums, start, pt);
}
```

