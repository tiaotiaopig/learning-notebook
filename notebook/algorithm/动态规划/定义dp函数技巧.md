# 定义dp数组技巧

> ​		一般，在动态规划的方法中，dp数组的定义都有一套固定的模式，按照正确的方式定义了dp数组，问题就解决了大半。
>
> ​		根据dp数组的定义，在推导动态转移方程的时候，就是数学归纳法：假设dp[i]成立（已经计算出来）那么如何利用已有信息，计算出dp[i + 1]
>
> ​		先总结一下，常见的设置dp数组的技巧，后续遇到了，会再补充进来

## 子串子序列

一般定义为：dp[i] 为**以nums[i] 结尾**的最长/短 子串/子序列长度

为什么要这样定义，因为子串/子序列问题都是要满足有序条件的，这样的定义，保证了顺序，也方便状态转移方程的建立，但是最后一个打表的元素，很可能就不是最终的答案

### 典型例题

1. 300 最长上升子序列

## 两个字符串（数组）

一般定义为：`dp[i][j]` 为考虑`str1`前i个字母，`str2`前j个字母

体现到状态转移上，`dp[i][j]`通常和`dp[i-1][j-1]`,`dp[i-1][j]`,`dp[i][j-1]` 状态有关

### 典型例题

1. 72 编辑距离
2. 1143 最长公共子序列
3. 583 [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)
4. 712 [两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

## 一个字符串的切分

一般定义为：`dp[i][j]`为考虑`str[i]` 开头，`srt[j]`结尾的子串，即`str[i...j]`

体现到状态转移上，`dp[i][j]`通常和`dp[i+1][j-1]`,`dp[i+1][j]`,`dp[i][j-1]` 状态有关

### 典型例题

1. 516 [最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)
2. 