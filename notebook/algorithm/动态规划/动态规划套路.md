# 动态规划套路

主要参考自 [labuladong](https://labuladong.gitee.io/algo/3/22/55/) 和 宫水三叶（leetcode上） 两位大佬

## 基本思路

**首先，动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

对此宫水大佬说：

**1. 我们是如何确定本题可以使用动态规划来解决的？**

通常我们要从**「有无后效性」**进行入手分析。

**「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。**

**「更加的学术表达是：当前某个状态确定后，之后的状态转移与之前的决策无关」**

如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。

另外一个更加实在的技巧，我们还可以通过 **数据范围** 来猜测是不是可以用 DP 来做。

因为 DP 是一个递推的过程，因此如果数据范围是 10^5 ~ 10^6 的话，可以考虑是不是可以使用一维 DP 来解决；如果数据范围是10^2 ~ 10^3 的话，可以考虑是不是可以使用二维 DP 来做 ...

**2. 我们是如何确定本题的状态定义的？**

说实话，DP 的状态定义很大程度是靠经验去猜的。

虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与**「结尾」**和**「答案」**有所关联的。

**3. 我们是如何确定状态转移方程的？**

通常来说，如果我们的状态定义猜对了，**「状态转移方程」**就是对**「最后一步的分情况讨论」**。

如果我们有一个对的**「状态定义」**的话，基本上**「状态转移方程」**就是呼之欲出。

因此一定程度上，**状态转移方程可以反过来验证我们状态定义猜得是否正确**：

如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是**状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程**。

**4. 对状态转移的要求是什么？**

我们的状态转移是要做到**「不漏」**还是**「不重不漏」**取决于问题本身：

- 如果是求最值的话，我们只需要确保**「不漏」**即可，因为重复不影响结果。
- 如果是求方案数的话，我们需要确保**「不重不漏」**。

**5. 我们是如何分析动态规划的时间复杂度的？**

对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。

因此一维 DP 的复杂度通常是线性的 ，而二维 DP 的复杂度通常是平方的 。

## 我的理解

宫水三叶大佬是个实战派，讲究意识，动态规划状态和最终所求有关，用猜的

拉动兄是个套路派，讲究套模板

我觉得书上说的更精髓一些

> 动态规划问题满足**最优性原理**，待求解的问题可以分解为若干个相互重叠的子问题，各个子问题的解只与它前面的子问题的解相关（无后效性？），而且各个子问题的解都是相对于当前状态的最优解，整个问题的最优解是由各个子问题的最优解构成。
>
> 最重要的就是划分子问题，也就是状态定义
>
> 然后根据状态（子问题）的重叠关系，确定递推关系（动态规划函数）

## 常用技巧

### 简化边界判断逻辑

在状态转移方程中，当前的状态一定是前一状态转移过来的，但是在边界上，可能就没有前一状态，这样对于边界，我们就要单独写边界的转移逻辑。代码量增多

一般地，我们可以定义`dp[m + 1][n + 1]`在外围填充了一圈0，这样在边界上，我们也可以统一转移逻辑

### 状态压缩

一般可以使用状态压缩优化的问题，其状态转移方程要满足一定条件：当前状态只与前一状态有关

通常表现为：`dp[i][j] = f(dp[i-1][...])`，这样`dp`就可以压缩一维，空间复用嘛

但是，在压缩的时候一定要特别注意遍历的顺序问题，我们要用到的前一状态的值一定要后更新，不然当我们需要前一状态的值，它已经被新的值覆盖，就没法得到正确答案了，一般表现为：二维的时候正着遍历，而压缩成一维的时候，就只能倒着遍历了

而打表的顺序，也有学问，正着打，反着打，斜着打，这主要取决于状态转移方程。

三叶大佬如是说：

通常 DP 的空间优化思路有两种：

- 滚动数组（两个一维，`dp[2][m]`，利用 `i & 0`，左右横跳，这样打表顺序就可以保持不变）
- 根据状态依赖调整迭代/循环的方向

其中滚动数组的优化方式，是我最推荐的，直接压缩掉一维，很大可能打表顺序要变，可理解性变差

