# 二分查找

## 理解

> **二分** 不是单纯指从有序数组中快速找某个数，这只是「二分」的一个应用。
>
> **二分**的本质是**两段性**，并非单调性。**只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」**。

## 模板

其中「二分」模板其实有两套，主要是根据 `check(mid)` 函数为 `true` 时，需要调整的是 `l` 指针还是 `r` 指针来判断。

+ 当 `check(mid) == true` 调整的是 `l` 时：计算 `mid` 的方式应该为 `mid = l + r + 1 >> 1`：

    (这种情况是两段中,小的那一段是我们想要的结果,我们要求的是,满足小段的最大值)

    ~~~java
    long l = 0, r = 1000009;
    while (l < r) {
        long mid = l + r + 1 >> 1;
        if (check(mid)) {
            l = mid;  // [l, mid]都满足条件,求小段的最大值,所以我们移动 left
        } else {
            r = mid - 1;  // [mid, r] 都不满足条件,所以移动 right
        }
    }
    ~~~

    

+ 当 `check(mid) == true` 调整的是 `r` 时：计算 `mid` 的方式应该为 `mid = l + r >> 1`：

    (这种情况是两段中,大的那一段是我们想要的结果,我们要求的是,满足大段的最小值)

    ~~~java
    long l = 0, r = 1000009;
    while (l < r) {
        long mid = l + r >> 1;
        if (check(mid)) {
            r = mid;  // 求大段中的最小值,所以我们移动 right
        } else {
            l = mid + 1;  // 因为大段是满足条件的,所以得出[l, mid] 都不满足条件
        }
    }
    ~~~

+ 一般地,我们还需要一个 check 函数, check (int mid) 检查 mid 是否满足条件,具体的校验逻辑,就跟题目的具体要求有关了

## 说明

> + 为啥修改左边指针 l 的时候要进行 +1 操作？
>     「模板一」的 +1 操作主要是为了避免发生「死循环」，因为 >> 和 直接使用 / 一样，都属于「下取整」操作。
>
>     考虑 l = 0, r = 1 的简单情况，如果不 +1 的话，l + r >> 1 等于 0 + 1 / 2，l 仍然是 0，陷入死循环。
>
> + 为啥模板不考虑 int 溢出问题？
>     事实上，二分模板确实有考虑 int 溢出的写法，评论区我也有提到，但是一般我们不会去用那样的模板，因为太难记了。
>
>     而且如果数据范围确实存在 int 溢出的情况，正确的做法是使用 long 数据结构，因为你无法确保只会在「二分」逻辑中进行下标运算，这里改用模板，在别的地方也可能会溢出。

## 典型例题

1. 1011 在 D 天内送达包裹的能力
2. 1482 制作 m 束花所需的最少天数
3. 33 搜索旋转排序数组
4. 81 搜索旋转排序数组II
5. 153 搜索旋转排序数组的最小值
6. 154 搜索旋转排序数组的最小值II
7. 34 在排序数组中查找元素的第一个和最后一个位置
8. 278 第一个错误的版本
9. 374 猜数字大小
10. 611 有效三角形的个数

45
