## java基础学习

---

1. 如果hashMap的key是一个自定义的类，怎么办？

   必须重写该类的hashcode()方法和equals()方法。

2. 请分析一下同步方法和同步代码块的区别是什么？

   答： 语法不同；在静态方法中，都是默认锁定类对象；

   同步块需要注明锁定对象，同步方法默认锁定this；

   在考虑性能方面，最好使用同步块来减少锁定范围提高并发效率。

3. 接口有什么限制？

   1、变量会被隐式地指定为public static final变量，并且只能是public static final变量，用private修饰会报编译错误 2、方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、final等修饰会报编译错误） 3、接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。1.8以后加了default修饰符允许有方法体。

4. 请你解释一下，什么是数据库中事务的ACID？

   \- 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； - 一致性(Consistent)：事务结束后系统状态是一致的； - 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； - 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。 关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。

5. 请谈谈，转发和重定向 之间的区别？

   转发和重定向的本质区别是：转发是服务端行为，由服务器发出请求；重定向是客户端行为，由客户端发出请求 。在请求转发的时候，客户端只需要发送一次请求，服务器端转发后将请求对象保存，地址栏中的URL地址不会改变，得到响应后服务器端再将响应发给客户端，转发之后共享的是同一个request；请求重定向是指服务端已经响应了客户端的请求并且返回，由客户端再次发起请求，地址栏中的URL会改变。请求转发的速度一般情况下比请求重定向要快。

6. 请简述一下SpringMVC的运行机制？以及运行机制的流程是什么？

   ![img](https://uploadfiles.nowcoder.com/images/20190408/92066590_1554713096249_DF3F3ADA1EA3353D6BF8A0164AAE9010)

7. 请说明一下JAVA虚拟机的作用是什么?

   JVM（Java虚拟机）负责将字节码转换为特定机器代码，消除了平台之间的差异性，JVM提供了内存管理/垃圾回收和安全机制等。

8. 请你简述一下synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？

   **相同点：**两者都是用来实现对某个资源的同步。

   两者区别如下：

   **用法不一样**。synchronized可以用于修饰方法，也可以用在代码块中。Lock需要指定起始和终点位置，一般放在try-finally结构中，try开始执行lock方法，finally中执行unlock方法。synchronized是托管给JVM执行的，Lock是通过代码执行的。

   **性能不一样**。在资源竞争不激烈情况下，synchronized的性能比Lock好，而在资源竞争激烈时，synchronized的性能下降很快，而Lock基本保持不变。

   **锁机制不一样**。synchronized获得锁和释放锁都是在块结构中，获取多个锁时必须以相反顺序释放，并且自动释放锁。Lock需要开发人员手动释放锁，并且放在finally中。

9. 请问object的hash该怎么设计

   在数组和hash表中要判断一个元素是不是存在的算法和效率是不一样的，数组需要对数组中每个元素的位置都进行检查,hash有一个更快速的查找方式. 一个好的 hash函数在不需要太多计算量的情况下，可以使得生成的位置分布接近于均匀分布,当两个不同的对象计算出相同的散列值时，我们称其为发生了 哈希碰撞

10. 请你介绍下数据库的三个范式

    第一范式：强调的是列的原子性，列不能分成其他几列，第一范式就是无重复的域。

    第二范式：首先是在第一范式的基础上，另外包含两部分的内容，一是表必须有主键，二是没有包含在主键中的列必须完全依赖于主键，二不能只依赖于主键的一部分。

    第三范式：在第二范式的基础之上，非主键列必须直接依赖于主键不能存在传递依赖。

