# synchronized 锁升级

> 当只有一个线程的时候，是偏向锁。可以减少获取锁和释放锁的开销。
>
> 原理是基于锁对象的对象头中的Mark Word 字段，这个字段主要记录对象的hashcode，分代年龄，是否偏向和锁标识。
>
> 加锁的逻辑：
>
> 1. 如果当前是未偏向状态，通过CAS操作修改锁对象头Mark Word字段为当前线程id。如果操作成功就可以获取锁，执行同步代码，但如果操作失败，就要进行锁升级。
> 2. 如果当前是已偏向状态，检查Mark Word 中的线程Id是否和当前线程id相同，如果相同，获取锁成功，如果不同，则需要进行锁升级。
>
> 锁升级前需要撤销偏向锁。撤销偏向锁主要看Mark Word中的线程id，如果对象的线程对象不再存活或者不再拥有锁，那么撤销后可以继续获取偏向锁。如果线程对象存活仍持有锁，那么就要升级为轻量级锁。
>
> 轻量级锁，会在当前线程栈帧中创建一个Lock Record，将Mark Word拷贝到这里，线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（`Lock Record`）的指针， 如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（`threshold`），轻量级锁将会膨胀为重量级锁。
>
> 重量级锁：它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁

![img](https://raw.githubusercontent.com/tiaotiaopig/feng-images-store/main/images/-----3.svg)

## 锁对象

Java 中的**每个对象都可以作为锁**，具体变现为以下3中形式：

1. 对于普通同步方法，锁是当前实例对象（**this**）
2. 对于静态同步方法，锁是当前类的 Class 对象(**Xxx.class**)
3. 对于同步方法块，锁是 synchronized 括号里配置的对象

一个线程试图访问同步代码块时，必须获取锁，在退出或者抛出异常时，必须释放锁。

## 实现方式

JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但是两者的实现细节不一样。

1. 代码块同步：通过使用 **monitorenter** 和 **monitorexit** 指令实现的
2. 同步方法：**ACC_SYNCHRONIZED** 标识

### 锁的实现

在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：**对象头，实例数据和对齐填充**。

对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。**其中每个部分占一个字长**。

多线程下 synchronized 的加锁就是**对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作**。

#### 1、MarkWord

Mark Word 用于存储对象自身的运行时数据，如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。
占用内存大小与虚拟机位长一致（32位JVM -> MarkWord是32位，64位JVM -> MarkWord是64位）。

#### 2、类型指针

虚拟机通过这个指针确定该对象是哪个类的实例。

## 锁升级

锁可以升级，但不能降级。即：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁是单向的。但是**锁可以撤销**。

## 1、偏向锁

偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。

> 为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。

如果支持偏向锁（没有计算 hashCode），那么在分配对象时，分配一个可偏向而未偏向的对象（MarkWord的最后 3 位为 101，并且 Thread Id 字段的值为 0）。

#### a、偏向锁的加锁

1. 偏向锁标志是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID，
   1. 如果成功，则获取偏向锁成功。
   2. 如果失败，则进行锁升级。
2. 偏向锁标志是已偏向状态
   1. MarkWord 中的线程 ID 是自己的线程 ID，成功获取锁
   2. MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级

偏向锁的锁升级需要进行偏向锁的撤销。

#### b、偏向锁的撤销

1. 对象是不可偏向状态
   1. 不需要撤销
2. 对象是可偏向状态
   1. MarkWord 中指向的线程不存活
      1. 允许重偏向：退回到可偏向但未偏向的状态
      2. 不允许重偏向：变为无锁状态
   2. MarkWord 中的线程存活
      1. 线程ID指向的线程仍然拥有锁
         1. 升级为轻量级锁，将 mark word 复制到线程栈中
      2. 不再拥有锁
         1. 允许重偏向：退回到可偏向但未偏向的状态
         2. 不允许重偏向：变为无锁状态

**小结：** 撤销偏向的操作需要在全局检查点执行。我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否 允许重偏向（`rebiasing`），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁 升级为轻量级锁，线程B自旋请求获得锁。

## 轻量级锁

线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（`Lock Record`）的指针， 如上图所示。如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（`threshold`），轻量级锁将会膨胀为重量级锁。

#### b、撤销流程

轻量级锁解锁时，如果对象的Mark Word仍然指向着线程的锁记录，会使用CAS操作， 将Dispalced Mark Word替换到对象头，如果成功，则表示没有竞争发生。如果失败， 表示当前锁存在锁竞争，锁就会膨胀为重量级锁。

## 3、重量级锁

重量级锁（`heavy weight lock`），是使用操作系统互斥量（`mutex`）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（`inflate`）为重量锁时，就不能再退回到轻量级锁。
