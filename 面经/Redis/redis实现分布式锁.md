# Redis 分布式锁

分布式锁主要是保证：多台服务器在执行同一段代码时，同一时刻只有一台服务器在执行。

场景：在电商秒杀场景下，商品库存量的更新。

为满足分布式锁的可用性，需要满足以下三个条件：

> 1. 互斥性。在任何时刻，保证只有一个客户端持有锁。
> 2. 不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。
> 3. 保证上锁和解锁都是同一个客户端。

实现分布式锁有很多种方法，以Redis为例，主要利用Redis的`setnx`命令。`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。

Redis的解决方案：

> 1. Redis是单线程的，使用**setnx**命令保证互斥，**setnx**加锁，**del**删除锁。
> 2. 给锁设置过期时间解决死锁,(**setnx** + **expire**)。
> 3. **setnx**的key就是锁，可以使用值标识锁的所有者，删除锁前检查是否是自己的锁（**get**  + **del**）

存在的问题：

> 1. 加锁并设置过期时间，是两个操作，假设一个客户端加锁后宕机，没法设置过期时间，需要保证两个操作原子性
>
>    解决：可以使用**set**命令的可选参数， `set lock uuid EX 30 NX`,只有键不存在时操作，设置键lock并设置过期时间。
>
> 2.  `get + del`也要保证原子性，反例有点强行，get完后，被另一个客户端强制加锁，这样就会删错锁
>
>    解决：将这个逻辑写成**Lua**脚本，让Redis执行，redis处理每个请求都是单线程执行，在执行一个请求时，其他请求必须等待。
>
> 3. 锁过期问题，过期时间小于资源操作时间，提前过期
>
>    加锁时，先设置一个过期时间，然后开启一个守护线程，定时检查这个锁的失效时间，如果锁快过期，而操作共享资源还没结束，就自动对锁进行续期，重新设置过期时间
>
>    在Java中可以使用**Redisson**这个redis的sdk，这个守护线程一般叫做“看门狗”线程。
>
> 4. 总结如下
>
>    死锁：设置过期时间
>
>    过期时间不好评估，提前过期：守护线程，自动续期
>
>    锁被别人释放：锁写入唯一标识，释放锁时先检查标识，再释放（释放别人的锁是锁提前过期导致的，所以有了自动续期的话，应该就不存在释放别人的锁情况）
>
> 5. 上面的锁不是可重入锁。
>
>    可重入锁简单理解就是，对外层函数加锁，访问内层需要锁的函数时，可以直接获取锁
>
>    在函数递归的时候也需要可重入锁，不然没法执行啦
>
>    使用redis哈希表存储重入的次数，重入次数为零时才可以释放锁。
>
> 6. 加锁失败，一直轮询加锁（自旋锁），耗费性能。
>
>    可以使用发布订阅机制（事件驱动，类似IO多路复用）加锁失败的时候，订阅锁释放的消息，然后阻塞自己，当持有锁的客户端释放锁的时候，发布锁释放的消息，这样想加锁的客户端收到锁释放的消息后，就可以解除阻塞，尝试加锁。

附录：

```
SET key value [EX seconds][PX milliseconds] [NX|XX]
```

- EX second: 设置键的过期时间为second秒；
- PX millisecond：设置键的过期时间为millisecond毫秒；
- NX：只在键不存在时，才对键进行设置操作；
- XX：只在键已经存在时，才对键进行设置操作；
- SET操作完成时，返回OK，否则返回nil。