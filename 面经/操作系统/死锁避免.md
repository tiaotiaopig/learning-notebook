# 死锁

<p data-pid="HUwq5tDy">那如何避免死锁呢？要避免死锁就需要分析死锁发生的条件，有个叫 Coffman 的牛人早就总结过了，只有以下这四个条件都发生时才会出现死锁：</p>

<ol><li data-pid="Unc3nNX0">互斥，共享资源 X 和 Y 只能被一个线程占用；</li><li data-pid="_P6KeWaC">占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li><li data-pid="kydS9qRW">不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li data-pid="O9PpndBI">循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ol>

<p data-pid="FhVFz3ML">其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p>

<ol><li data-pid="DTIhxKYi">对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li data-pid="5h4Uekjt">对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li data-pid="j7m-6GbM">对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li></ol>

