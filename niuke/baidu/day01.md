# baidu 牛客试题（01）

## 选择题

> 1. csrf,ssrf
>
> 2. 线程池拒绝策略：
>
>      （1） AbortPolicy 。丢弃任务，并抛出RejectedExecutionException异常，线程池默认拒绝策略；
>
>      （2） DiscardPolicy。丢弃任务，不抛出异常；
>
>      （3） DiscardOldesPolicy.丢弃队列最前面的任务，然后重新提交被拒绝的任务；
>
>      （4） CallerRunPolicy。由调用的线程处理该任务，谁调用谁的线程处理。
>
> 3. \1. 连接点（Joinpoint）
>    连接点描述的是程序执行的某个特定位置。如一个类的初始化前、初始化后，或者类的某个方法调用前、调用后、方法抛出异常后等等。一个类或一段程序代码拥有一些具有边界性质的特定点，这些特定点就称为连接点。连接点用来定义在目标程序的哪里通过AOP加入新的逻辑。
>
>    Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。
>    连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。
>    执行点：即程序执行流程中的某个点。如执行某个语句或者语句块、执行某个方法、装载某个类、抛出某个异常……
>
>    \2. 切入点（Pointcut）
>    切入点是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。每个类都拥有多个连接点：例如 UserService类中的所有方法实际上都是连接点，即连接点是程序类中客观存在的事物。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。
>
>    \3. 通知（Advice）
>    切面在某个具体的连接点采取的行为或行动，称为通知。切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。
>    常用的通知接口有
>
>    前置通知：org.springframework.aop.MethodBeforeAdvice
>    后置通知：org.springframework.aop.AfterReturningAdvice
>    异常通知：org.springframework.aop.ThrowsAdvice
>    该接口没有要实现的方法，需要自定义一个afterThrowing()方法。
>    环绕通知：org.aopalliance.intercept.MethodInterceptor
>
>    \4. 通知器（Advisor）
>    通知器由一个切入点（pointcut）和一个通知（Advice）组成。通知就是增强的那部分功能代码，如记录日志代码、控制权限代码。
>
>    \5. 切面（Aspect）
>    与通知器（advisor）类似都是通知+切入点。区别在于，切面中的类无需实现通知接口，但需要在配置文件中指定类中的方法名；而通知器仅需指定类名即可，因为通知器中的类都实现了通知接口，很明确的知道通知方法是哪个。
>
>    \6. 目标(Target)
>    被通知的对象（方法）
>
>    \7. 代理(Proxy)
>
>    向目标对象应用通知之后创建的对象
>
> 4. JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代,其中，年轻代：serial GC、parNew GC、paraller Scavenge GC
>
>    老年代：serial old GC 、paraller old GC、CMS
>
> 5. 分布式锁的实现方式：使用数据库乐观锁实现，使用redis的setnx()、expire()方法，用于分布式锁，基于Zookeeper实现分布式锁
>
> 6. 折半查找
>
> 7. 哈夫曼编码
>
> 8. 出栈顺序
>
> 9. sql, (limit m , n) 从第m条记录开始（从0开始），选取n条记录（n = -1,从m到最后），（limit m）取出前m条记录

