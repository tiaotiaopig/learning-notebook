# python字典

## 概述

> 1. 字典由键及其相应的值组成，这种**键值对**称为**项(item)**。
> 2. 每个键与其值之间都用冒号（ :）分隔，项之间用逗号分隔
> 3. 而整个字典放在花括号内。
> 4. 空字典（没有任何项）用两个花括号表示，类似于下面这样： {}  
> 5. 键唯一,值不唯一
> 6. 示例:`{'name': '小明', 'age': 15}`
> 7. `list`,`str`,`tuple`,`dict`都是类,但是可以调用其构造函数完成类型转化,感觉上又是函数

## 基本操作

```python
# 创建一个字典
d = {}
d = dict()

# 返回字典d包含的项（键值对）数。
len(d)

# 返回与键k相关联的值。
d[k]

# 将值v关联到键k,没有则新建
d[k] = v

# 删除键为k的项。
del d[k]

# 检查字典d是否包含键为k的项
k in d
```

> 键的类型：字典中的键可以是任何不可变的类型，如:整数, 浮点数（实数）、字符串或元组。
>
> 自动添加：即便是字典中原本没有的键，也可以给它赋值，这将在字典中创建一个新项。
> 然而，如果不使用append或其他类似的方法，就不能给列表中没有的元素赋值。
>
> 成员资格：表达式**k in d**（其中d是一个字典）查找的是键而不是值，而表达式v in l（其
> 中l是一个列表）查找的是值而不是索引。这看似不太一致，但你习惯后就会觉得相当自
> 然。毕竟如果字典包含指定的键，检查相应的值就很容易。  

## 常用方法

```python
from copy import deepcopy

dict_d = {'name': '小明'}
# 删除所有字典项
dict_d.clear()

# 浅拷贝,值没复制
dict_d.copy()

# 执行深拷贝
deepcopy(dict_d)

# 使用键列表创建新字典
dict.fromkeys(['name', 'age'])

# [key]访问时,值不存在会报错,get(key)会返回None
dict_d.get('age')

# 返回一个包含所有字典项的列表,字典项是一个元组(key, value)
# 对其修改时,会影响原有字典
items = dict_d.items()

# 键集合
dict_d.keys()

# 获取键对应的值,并将对应项删除,键不存在也会报错
dict_d.pop('name')

# 使用项或者项的容器更新字典,键存在则替换,不存在则添加
dict_d.update([('school', 'yizhong'), ('phone', 12456)])

# 返回值列表,可能包含重复值
dict_d.values()
```

